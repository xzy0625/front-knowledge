import{_ as i,c as e,ag as a,o as l}from"./chunks/framework.CC6fhYpF.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/jsvascript/promise/自己实现promise.md","filePath":"blogs/jsvascript/promise/自己实现promise.md","lastUpdated":1732159975000}'),o={name:"blogs/jsvascript/promise/自己实现promise.md"};function t(n,s,r,h,p,d){return l(),e("div",null,s[0]||(s[0]=[a(`<ol><li>promise传入的函数是立马执行的</li><li>promise变为fullied和rejected之后是不可更改的</li></ol><h3 id="_1-调用-resolve-时的处理" tabindex="-1">1. 调用 <code>resolve</code> 时的处理 <a class="header-anchor" href="#_1-调用-resolve-时的处理" aria-label="Permalink to &quot;1. 调用 \`resolve\` 时的处理&quot;">​</a></h3><ul><li><strong>普通值</strong>：如果传入的是一个普通值（如字符串、数字、对象等），Promise 会将其视为已兑现的值，Promise 的状态会变为已兑现，且该值会被传递给 <code>onFulfilled</code> 回调。</li><li><strong>Promise 对象</strong>：如果传入的是一个 Promise 对象，Promise 会等待这个 Promise 兑现或拒绝： <ul><li>如果传入的 Promise 兑现，返回的 Promise 也会兑现，并且其值为传入 Promise 的值。</li><li>如果传入的 Promise 拒绝，返回的 Promise 也会拒绝，并且其拒绝原因为传入 Promise 的拒绝原因。</li></ul></li><li><strong>其他对象（thenable）</strong>：如果传入的是一个具有 <code>then</code> 方法的对象（即 thenable），Promise 会调用这个对象的 <code>then</code> 方法，并将 <code>resolve</code> 和 <code>reject</code> 作为参数传入： <ul><li>如果 <code>then</code> 方法调用 <code>resolve</code>，返回的 Promise 会兑现。</li><li>如果 <code>then</code> 方法调用 <code>reject</code>，返回的 Promise 会拒绝。</li><li>如果 <code>then</code> 方法抛出错误，返回的 Promise 也会拒绝，拒绝原因是抛出的错误。</li></ul></li></ul><h3 id="_2-调用-reject-时的处理" tabindex="-1">2. 调用 <code>reject</code> 时的处理 <a class="header-anchor" href="#_2-调用-reject-时的处理" aria-label="Permalink to &quot;2. 调用 \`reject\` 时的处理&quot;">​</a></h3><ul><li><strong>普通值</strong>：如果传入的是一个普通值，Promise 会将其视为拒绝的原因，Promise 的状态会变为已拒绝，且该值会被传递给 <code>onRejected</code> 回调。</li><li><strong>Promise 对象</strong>：如果传入的是一个 Promise 对象，Promise 会等待这个 Promise 兑现或拒绝： <ul><li>如果传入的 Promise 兑现，返回的 Promise 仍然是拒绝状态，拒绝原因为传入的 Promise 的拒绝原因。</li><li>如果传入的 Promise 拒绝，返回的 Promise 也会拒绝，并且其拒绝原因为传入 Promise 的拒绝原因。</li></ul></li><li><strong>其他对象（thenable）</strong>：如果传入的是一个具有 <code>then</code> 方法的对象，Promise 的行为与上述相同，调用 <code>then</code> 方法并处理结果。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><code>resolve</code> 和 <code>reject</code> 的处理方式主要取决于传入的值是否是 Promise 或 thenable。</li><li>对于 <code>resolve</code>，如果传入的是 Promise，则会根据其状态决定返回 Promise 的状态；对于 <code>reject</code>，同样的逻辑适用。</li><li>对于普通值，<code>resolve</code> 会将其视为成功的结果，而 <code>reject</code> 会将其视为失败的原因。</li></ul><p>promise的缺点： Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span></code></pre></div>`,9)]))}const E=i(o,[["render",t]]);export{c as __pageData,E as default};
