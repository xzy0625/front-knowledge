import{_ as i,c as a,ag as t,o as n}from"./chunks/framework.CP8Mv0l3.js";const g=JSON.parse('{"title":"node实现路径别名","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/node/node实现路径别名.md","filePath":"blogs/node/node实现路径别名.md","lastUpdated":1735875453000}'),e={name:"blogs/node/node实现路径别名.md"};function l(h,s,p,r,o,k){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="node实现路径别名" tabindex="-1">node实现路径别名 <a class="header-anchor" href="#node实现路径别名" aria-label="Permalink to &quot;node实现路径别名&quot;">​</a></h1><h2 id="一-什么是路径别名" tabindex="-1">一：什么是路径别名 <a class="header-anchor" href="#一-什么是路径别名" aria-label="Permalink to &quot;一：什么是路径别名&quot;">​</a></h2><p>开发前端应用时，经常看到类似 <strong>@utils/</strong>，<strong>@components/</strong> 的引入路径，如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@utils/request&#39;</span></span></code></pre></div><p>通常这种引入路径就是路径别名，因为在实际的文件系统中，基本不会存在像 <strong>@utils/</strong> 的文件路径。如果你的项目中有用到，可以去查看 <strong>Webpack/Vite</strong> 配置文件是否配置了 <a href="https://cn.vitejs.dev/config/shared-options.html#resolve-alias" target="_blank" rel="noreferrer"><strong>resolve.alias</strong></a>。配置了之后在构建的时候，这些别名会被这些打包框架替换为实际的文件路径，从而正确的找到文件。</p><p>所以路径别名，故名思意，就是为引入模块的路径定义一个新的、简化的名字，然后 <strong>import/require</strong> 时使用该别名作为引入路径，而程序运行时，别名路径会经由相关工具处理，转换为原始文件路径，以正确加载对应资源。</p><h2 id="二-路径别名的作用" tabindex="-1">二：路径别名的作用 <a class="header-anchor" href="#二-路径别名的作用" aria-label="Permalink to &quot;二：路径别名的作用&quot;">​</a></h2><ul><li><strong>提高可读性</strong>，路径别名与某个目录或文件存在映射关系，引入的模块位于哪个目录，一目了然。</li><li><strong>提高编码效率</strong>，一个别名可以到处使用，无论是文件结构嵌套多少层，相比之下，无数个 <strong>../</strong> 写起来麻烦还不好看。</li><li><strong>重构简单</strong>，若项目结构变化，只需要修改别名配置即可，无需全局搜索挨个修改引入路径，极大的减少工作量。</li><li><strong>避免路径冲突</strong>，在大型项目中可能存在相同的文件或目录，通过路径可以明确区分某个模块属于哪个目录。</li><li><strong>工具支持度高</strong>，目前主流的构建工具，如 <strong>vite</strong>、<strong>Webpack</strong> 等，都支持路径别名配置。</li></ul><h2 id="三-客户端启用路径别名" tabindex="-1">三：客户端启用路径别名 <a class="header-anchor" href="#三-客户端启用路径别名" aria-label="Permalink to &quot;三：客户端启用路径别名&quot;">​</a></h2><p>在前端项目中启动路径别名只需要在打包工具中配置即可，如果项目中使用了<code>ts</code>，还需要额外的进行<code>tsconfig.json</code>配置。示例如下：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">    ...</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;paths&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;@controllers/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./src/controllers/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;@services/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./src/services/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;@entities/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./src/entities/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上配置定义了几个路径别名：</p><ul><li><strong>@controllers</strong>：映射到 <code>./src/controllers</code> 目录。</li><li><strong>@services</strong>：映射到 <code>./src/services</code> 目录。</li><li><strong>@entities</strong>：映射到 <code>./src/entities</code> 目录。</li></ul><p>比如引入 <code>import { UserController } from &#39;@controllers/user.controller&#39;</code>，实际引入的是 <strong>./src/controllers/user.controller</strong>。</p><h3 id="路径映射规则" tabindex="-1">路径映射规则： <a class="header-anchor" href="#路径映射规则" aria-label="Permalink to &quot;路径映射规则：&quot;">​</a></h3><ul><li><p>若 <code>tsconfig.json</code> 配置了 <a href="https://www.typescriptlang.org/tsconfig/#baseUrl" target="_blank" rel="noreferrer"><code>baseUrl</code></a>，则 <a href="https://www.typescriptlang.org/tsconfig/#paths" target="_blank" rel="noreferrer"><code>paths</code></a> 配置的文件路径相对于 <a href="https://www.typescriptlang.org/tsconfig/#baseUrl" target="_blank" rel="noreferrer"><code>baseUrl</code></a> 配置的路径；</p></li><li><p>若未配置 <a href="https://www.typescriptlang.org/tsconfig/#baseUrl" target="_blank" rel="noreferrer"><code>baseUrl</code></a>，则相对于 <code>tsconfig.json</code> 文件位置。</p></li></ul><h2 id="四-node中集成路径别名" tabindex="-1">四：node中集成路径别名 <a class="header-anchor" href="#四-node中集成路径别名" aria-label="Permalink to &quot;四：node中集成路径别名&quot;">​</a></h2><p>如果是在node环境下。就算配置了 <code>TypeScript</code>的<code>paths</code>，虽然<code>TypeScript</code>检验通过，但在程序运行时，仍然会报 &quot;找不到模块&quot; 的错误。这是因为在node中没有vite/webpack这些工具对路径别名做转换，所以对于路径别名文件系统没办法识别出来。要实现的话可以使用第三方包</p><h3 id="集成-module-alias" tabindex="-1">集成 <a href="https://github.com/ilearnio/module-alias" target="_blank" rel="noreferrer"><code>module-alias</code></a> <a class="header-anchor" href="#集成-module-alias" aria-label="Permalink to &quot;集成 [\`module-alias\`](https://github.com/ilearnio/module-alias)&quot;">​</a></h3><p>在node中可以使用<strong>module-alias</strong>来实现路径别名的效果，使用module-alias添加别名有两种方式：</p><blockquote><ol><li>在package.json进行配置</li><li>使用API进行动态添加别名 具体使用可以查看<a href="https://github.com/ilearnio/module-alias" target="_blank" rel="noreferrer">官方文档</a></li></ol></blockquote><h3 id="module-alias-原理" tabindex="-1">module-alias 原理 <a class="header-anchor" href="#module-alias-原理" aria-label="Permalink to &quot;module-alias 原理&quot;">​</a></h3><p><code>module-alias的</code>原理也非常简单，整个代码也就两百多行。主要原理是通过改写<code>Module._resolveFilename</code>模块查找的函数，内部维护一个moduleAliases映射，在进行路径解析的时候通过映射的方式找到真实的路径。</p><h3 id="module-alias-坑点" tabindex="-1">module-alias 坑点 <a class="header-anchor" href="#module-alias-坑点" aria-label="Permalink to &quot;module-alias 坑点&quot;">​</a></h3><p>由于我们项目打包之后代码一般放在<code>dist</code>目录中，而开发的时候代码放在<code>src</code>目录下，所以会导致开发的时候路径可以找到，但是发布之后模块就会找不到。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_moduleAliases&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;@&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;src&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 打包之后这里应该是dist</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><p>解决这个问题我们可以动态的注入路径，通过判断环境来实现不同的环境配置不同的根路径。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { isDev } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;path&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;module-alias/register&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addAliases</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module-alias&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initAlias</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;development&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../../src&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../../dist/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 配置路径别名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addAliases</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;@root&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;@controller&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/controller\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initAlias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>然后在项目的入口引入这个文件即可。</p>`,29)]))}const c=i(e,[["render",l]]);export{g as __pageData,c as default};
