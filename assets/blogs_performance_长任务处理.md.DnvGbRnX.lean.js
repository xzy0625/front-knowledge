import{_ as i,c as a,ag as n,o as t}from"./chunks/framework.BcCMgSRd.js";const e="/front-knowledge/assets/image-20250113163752782.B7QCtunD.png",l="/front-knowledge/assets/image-20250113163810936.BcjFmNXu.png",p="/front-knowledge/assets/image-20250113163826094.57WFSzOg.png",h="/front-knowledge/assets/image-20250113163838720.C8b47s5d.png",k="/front-knowledge/assets/image-20250113163852034.OKguVAS4.png",m=JSON.parse('{"title":"长任务处理","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/performance/长任务处理.md","filePath":"blogs/performance/长任务处理.md","lastUpdated":1737013267000}'),r={name:"blogs/performance/长任务处理.md"};function o(d,s,E,g,c,y){return t(),a("div",null,s[0]||(s[0]=[n('<h1 id="长任务处理" tabindex="-1">长任务处理 <a class="header-anchor" href="#长任务处理" aria-label="Permalink to &quot;长任务处理&quot;">​</a></h1><p>实际上网页里卡顿的产生基本上都是由于长任务导致的。当然，能阻塞用户操作的，我们说的便是主线程上的长任务。 浏览器中的长任务可能是 JavaScript 的编译、解析 HTML 和 CSS、渲染页面，或者是我们编写的 JavaScript 中产生了长任务导致。一般为了最好的用户体验，我们都需要保证长任务在50ms内处理完，但最好是16ms一帧内完成。</p><h2 id="_50-毫秒与长任务" tabindex="-1">50 毫秒与长任务 <a class="header-anchor" href="#_50-毫秒与长任务" aria-label="Permalink to &quot;50 毫秒与长任务&quot;">​</a></h2><p>这个数值并不是随便写的，主要来自于 Google 的 <a href="https://web.dev/articles/rail" target="_blank" rel="noreferrer">RAIL 模型</a>。</p><h3 id="rail-模型" tabindex="-1">RAIL 模型 <a class="header-anchor" href="#rail-模型" aria-label="Permalink to &quot;RAIL 模型&quot;">​</a></h3><p>RAIL 表示 Web 应用生命周期的四个不同方面：<strong>响应（Response）</strong>、<strong>动画（Animation）</strong>、<strong>空闲（Idel）<strong>和</strong>加载（Load）</strong>。由于用户对每种情境有不同的性能预期，因此，系统会根据情境以及关于用户如何看待延迟的用户体验调研来确定效果目标。</p><p>人机交互学术研究由来已久，在 <a href="https://www.nngroup.com/articles/response-times-3-important-limits/" target="_blank" rel="noreferrer">Jakob Nielsen’s work on response time limits</a> 中提出三个阈值：</p><ul><li>100 毫秒：大概是让用户感觉系统立即做出反应的极限，这意味着除了显示结果之外不需要特殊的反馈</li><li>1 秒：大概是用户思想流保持不间断的极限，即使用户会注意到延迟。一般情况下，大于0.1秒小于1.0秒的延迟不需要特殊反馈，但用户确实失去了直接操作数据的感觉</li><li>10 秒：大概是让用户的注意力集中在对话上的极限。对于较长的延迟，用户会希望在等待计算机完成的同时执行其他任务，因此应该向他们提供反馈，指示计算机预计何时完成。如果响应时间可能变化很大，则延迟期间的反馈尤其重要，因为用户将不知道会发生什么。</li></ul><p>在此基础上，如今机器性能都有大幅度的提升，因此基于用户的体验，RAIL 增加了一项：</p><ul><li>0-16 ms：大概是用户感受到流畅的动画体验的数值。只要每秒渲染 60 帧，这类动画就会感觉很流畅，也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），让应用生成一帧大约 10 毫秒</li></ul><p>由于这篇文章我们讨论的是长任务相关，因此主要考虑生命周期中的响应（Response），目标便是要求 100 毫秒内获得可见响应。</p><h3 id="在-50-毫秒内处理事件" tabindex="-1">在 50 毫秒内处理事件 <a class="header-anchor" href="#在-50-毫秒内处理事件" aria-label="Permalink to &quot;在 50 毫秒内处理事件&quot;">​</a></h3><p>RAIL 的目标是在 100 毫秒内完成由用户输入发起的转换，让用户感觉互动是瞬时完成的。</p><p>目标是 100 毫秒，但是页面运行时除了输入处理之外，通常还会执行其他工作，并且这些工作会占用可用于获得可接受输入响应的部分时间。</p><p>因此，为确保在 100 毫秒内获得可见响应，RAIL 的准则是在 50 毫秒内处理用户输入事件：</p><blockquote><p>为确保在 100 毫秒内获得可见响应，请在 50 毫秒内处理用户输入事件。这适用于大多数输入，例如点击按钮、切换表单控件或启动动画。这不适用于轻触拖动或滚动。</p></blockquote><p>除了响应之外，RAIL 对其他的生命周期也提出了对应的准则，总体为：</p><ul><li>响应（Response）：在 50 毫秒内处理事件</li><li>动画（Animation）：在 10 毫秒内生成一帧</li><li>空闲（Idel）：最大限度地延长空闲时间</li><li>加载（Load）：提交内容并在 5 秒内实现互动</li></ul><p>具体每个行为的目标和准则是如何考虑和确定的，大家可以自行学习，这里不再赘述。</p><blockquote><p>在这个模型中，对于响应用户输入的操作，建议在 100 毫秒内给出反馈。对于动画，建议每个任务不超过 16 毫秒（理想情况下是 10 毫秒），以保持流畅的 60 FPS（每秒帧数）。而对于空闲时的任务处理，建议将任务切分为多个小块，每个块不超过 50 毫秒，以便在主线程空闲时快速执行，同时留出时间处理输入响应。</p></blockquote><h2 id="长任务优化" tabindex="-1">长任务优化 <a class="header-anchor" href="#长任务优化" aria-label="Permalink to &quot;长任务优化&quot;">​</a></h2><p>网页加载时，长时间任务可能会占用主线程，使页面无法响应用户输入（即使页面看起来已就绪）。点击和点按通常不起作用，因为尚未附加事件监听器、点击处理程序等。</p><p>基于前面介绍的 RAIL 模型，我们可以将超过 50 毫秒的任务称之为长任务，即：任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。</p><p>实际上，Chrome 浏览器中的 Performance 面板也是如此定义的，我们录制一段 Performance，当主线程同步执行的任务超过 50 毫秒时，该任务块会被标记为红色。</p><p><img src="'+e+'" alt="image-20250113163752782"></p><h3 id="一、识别长任务" tabindex="-1">一、识别长任务 <a class="header-anchor" href="#一、识别长任务" aria-label="Permalink to &quot;一、识别长任务&quot;">​</a></h3><p>一般来说，在前端网页中容易出现的长任务包括：</p><ul><li>大型的 JavaScript 代码加载</li><li>解析 HTML 和 CSS</li><li>DOM 查询/DOM 操作</li><li>运算量较大的 JavaScript 脚本的执行</li></ul><h4 id="_1-使用-chrome-devtools" tabindex="-1">1. 使用 Chrome Devtools <a class="header-anchor" href="#_1-使用-chrome-devtools" aria-label="Permalink to &quot;1. 使用 Chrome Devtools&quot;">​</a></h4><p>我们可以在 Chrome 开发者工具中，通过录制 Performance 的方式，手动查找时长超过 50 毫秒的脚本的“长红/黄色块”，然后分析这些任务块的执行内容，来识别出长任务。</p><p>我们可以选择 Bottom-Up 和 Group by Activity 面板来分析这些长任务（关于如何使用 Performance 面板，可以参考<a href="https://developer.chrome.com/docs/devtools/performance?hl=zh-cn" target="_blank" rel="noreferrer">分析运行时性能</a>一文）：</p><p><img src="'+l+`" alt="image-20250113163810936"></p><p>比如在上图中，导致任务耗时较长的原因是一组成本高昂的 DOM 查询。</p><h4 id="_2-使用-long-tasks-api" tabindex="-1">2. 使用 Long Tasks API <a class="header-anchor" href="#_2-使用-long-tasks-api" aria-label="Permalink to &quot;2. 使用 Long Tasks API&quot;">​</a></h4><p>我们还可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceLongTaskTiming" target="_blank" rel="noreferrer">Long Tasks API</a> 来确定哪些任务导致互动延迟：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PerformanceObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> perfEntries</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> perfEntries.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 分析长任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ entryTypes: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;longtask&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span></code></pre></div><h4 id="_3-识别大型-javascript-脚本" tabindex="-1">3. 识别大型 JavaScript 脚本 <a class="header-anchor" href="#_3-识别大型-javascript-脚本" aria-label="Permalink to &quot;3. 识别大型 JavaScript 脚本&quot;">​</a></h4><p>大型脚本通常是导致耗时较长的任务的主要原因，我们可以想办法来识别。</p><p>除了使用上述的方法，我们还可以使用<code>PerformanceObserver</code>识别：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PerformanceObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entries</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PerformanceResourceTiming</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 获取 JavaScript 资源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (entry.initiatorType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> startTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // JavaScript 资源加载完成</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> endTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 如果此时耗时大于 50 ms，则可任务出现了长任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isLongTask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({entryTypes: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;resource&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]});</span></span></code></pre></div><p>这种方式我们还可以通过<code>entry.name</code>拿到对应的加载资源，针对性地进行处理。</p><h4 id="_4-自定义性能指标" tabindex="-1">4. 自定义性能指标 <a class="header-anchor" href="#_4-自定义性能指标" aria-label="Permalink to &quot;4. 自定义性能指标&quot;">​</a></h4><p>除此之外，我们还可以通过在代码中埋点，自行计算执行耗时，从而针对可预见的场景识别出长任务：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可预见的大任务执行前打点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bigTask:start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doBigTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行后打点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bigTask:end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测量该任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">measure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bigTask&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bigTask:start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bigTask:end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>再配合<code>PerformanceObserver</code>获取对应的性能数据，大于 50 毫秒则可以判断为长任务、</p><h3 id="二、优化长任务" tabindex="-1">二、优化长任务 <a class="header-anchor" href="#二、优化长任务" aria-label="Permalink to &quot;二、优化长任务&quot;">​</a></h3><p>发现长任务之后，我们就可以进行对应的长任务优化。</p><h4 id="_1-过大的-javascript-脚本" tabindex="-1">1. 过大的 JavaScript 脚本 <a class="header-anchor" href="#_1-过大的-javascript-脚本" aria-label="Permalink to &quot;1. 过大的 JavaScript 脚本&quot;">​</a></h4><p>大型脚本通常是导致耗时较长的任务的主要原因，尤其是首屏加载时尽量避免加载不必要的代码。</p><p>我们可以考虑拆分这些脚本：</p><ol><li>首屏加载，仅加载必要的最小 JavaScript 代码。</li><li>其他 JavaScript 代码进行模块化，进行分包加载。</li><li>通过预加载、闲时加载等方式，完成剩余所需模块的代码加载。</li></ol><p>拆分 JavaScript 脚本，使得用户打开页面时，只发送初始路由所需的代码。这样可以最大限度地减少需要解析和编译的脚本量，从而缩短网页加载时，也有助于提高 First Input Delay (FID) 和 Interaction to Next Paint (INP) 时间。</p><p>有很多工具可以帮助我们完成这项工作：</p><ul><li><a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noreferrer">webpack</a></li><li><a href="https://parceljs.org/code_splitting.html" target="_blank" rel="noreferrer">Parcel</a></li><li><a href="https://rollupjs.org/guide/en#dynamic-import" target="_blank" rel="noreferrer">Rollup</a></li></ul><p>这些热门的模块打包器，都支持动态加载的方式来拆分 JavaScript 脚本。我们甚至可以限制每个构建模块的大小，来防止某个模块的 JavaScript 脚本过大，具体的使用方式大家可以自行搜索。</p><h4 id="_2-过长的-javascript-执行任务" tabindex="-1">2. 过长的 JavaScript 执行任务 <a class="header-anchor" href="#_2-过长的-javascript-执行任务" aria-label="Permalink to &quot;2. 过长的 JavaScript 执行任务&quot;">​</a></h4><p>主线程一次只能处理一个任务。如果任务的延时时间超过某一点（确切来说是 50 毫秒），则会被归类为耗时较长的任务。</p><p>对于这种过长的执行任务，优化方案也十分直接：<strong>任务拆分</strong>，直观来看就是这样：</p><p><img src="`+p+`" alt="image-20250113163826094"></p><p>一般来说，任务拆分可以分为两种：</p><ol><li>串行执行的不同执行任务。</li><li>单个超大的执行任务。</li></ol><h4 id="串行任务的拆分" tabindex="-1">串行任务的拆分 <a class="header-anchor" href="#串行任务的拆分" aria-label="Permalink to &quot;串行任务的拆分&quot;">​</a></h4><p>对于串行执行的不同任务，可以将不同任务的调用从同步改成异步即可，比如 <a href="https://web.dev/articles/optimize-long-tasks" target="_blank" rel="noreferrer">Optimize long tasks</a> 这篇文章中详细介绍的：</p><p><code>saveSettings()</code>的函数，该函数会调用五个函数来完成某些工作：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> saveSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  validateForm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  showSpinner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  saveToDatabase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  updateUI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sendAnalytics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+h+'" alt="image-20250113163838720"></p><p>对这些串行任务进行拆分有很多种方式，比如：</p><ul><li>使用<code>setTimeOut()</code>/<code>postTask()</code>实现异步</li><li>自行实现任务管理器，管理串行任务执行，每执行一个任务后释放主线程，再执行下一个任务（还需考虑优先级执行任务）</li></ul><p>具体的代码可以参考 <a href="https://web.dev/articles/optimize-long-tasks" target="_blank" rel="noreferrer">Optimize long tasks</a> 该文章，理想的优化效果为：</p><p><img src="'+k+'" alt="image-20250113163852034"></p><h4 id="单个超大任务的拆分" tabindex="-1">单个超大任务的拆分 <a class="header-anchor" href="#单个超大任务的拆分" aria-label="Permalink to &quot;单个超大任务的拆分&quot;">​</a></h4><p>有时候我们的应用中需要做大量的运算，比如对上百万个数据做一系列的计算，此时我们可以考虑进行分批拆分。</p><p>拆分的时候需要注意几个事情：</p><ol><li>尽量将每个小任务拆成 50 毫秒左右的执行时间。</li><li>大任务分批执行，会由同步执行变为异步执行，需要考虑中间态（是否有新的任务插入，是否会重复执行）。</li></ol><p>这里的具体实现可以参考<code>react-schduler</code></p>',75)]))}const u=i(r,[["render",o]]);export{m as __pageData,u as default};
