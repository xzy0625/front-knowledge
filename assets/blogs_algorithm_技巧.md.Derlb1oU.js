import{_ as a,c as o,ag as t,o as l}from"./chunks/framework.BcCMgSRd.js";const u=JSON.parse('{"title":"算法技巧","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/algorithm/技巧.md","filePath":"blogs/algorithm/技巧.md","lastUpdated":1737013267000}'),r={name:"blogs/algorithm/技巧.md"};function i(n,e,d,c,s,h){return l(),o("div",null,e[0]||(e[0]=[t('<h1 id="算法技巧" tabindex="-1">算法技巧 <a class="header-anchor" href="#算法技巧" aria-label="Permalink to &quot;算法技巧&quot;">​</a></h1><h2 id="使用哨兵-sentinel-元素" tabindex="-1">使用哨兵（Sentinel）元素 <a class="header-anchor" href="#使用哨兵-sentinel-元素" aria-label="Permalink to &quot;使用哨兵（Sentinel）元素&quot;">​</a></h2><p>在数组的开头或结尾添加一个特殊的元素，这样可以避免在循环中进行边界检查。例如，如果你在处理一个需要比较当前元素与下一个元素的问题，可以在数组末尾添加一个无效值或最大值，这样就可以在不越界的情况下完成比较。</p><h2 id="统一处理边界" tabindex="-1">统一处理边界 <a class="header-anchor" href="#统一处理边界" aria-label="Permalink to &quot;统一处理边界&quot;">​</a></h2><p>在循环之前或之后统一处理边界情况。比如，如果你需要在数组中查找一个元素，并且需要特别处理找到元素在数组第一个或最后一个位置的情况，可以在循环外单独检查这些情况。</p><h2 id="扩展数组范围" tabindex="-1">扩展数组范围 <a class="header-anchor" href="#扩展数组范围" aria-label="Permalink to &quot;扩展数组范围&quot;">​</a></h2><p>在处理问题时，可以考虑将数组视为循环数组，这样数组的最后一个元素后面就是第一个元素，反之亦然。这种方法适用于某些特定类型的问题，可以避免处理边界的复杂性。</p><h2 id="使用左闭右开区间" tabindex="-1">使用左闭右开区间 <a class="header-anchor" href="#使用左闭右开区间" aria-label="Permalink to &quot;使用左闭右开区间&quot;">​</a></h2><blockquote><p>可以很好的规避开边界情况</p></blockquote><p>为啥要左闭右开，我就是想两端都开，或者两端都闭，不行么？</p><p>在 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/" target="_blank" rel="noreferrer">滑动窗口算法核心框架</a> 中定义滑动窗口的边界时也会有类似的问题，这里我也解释一下。</p><p><strong>理论上，你可以随机设计区间的开闭，但一般设计为左闭右开区间是最方便处理的</strong>。</p><p>因为这样初始化 <code>start = end = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>end</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。</p><p>如果你设置为两端都开的区间，那么让 <code>end</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就已经包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦，如果你非要使用的话，需要在代码中做一些特殊处理。</p><h2 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h2><p>动态规划的的四个解题步骤是：</p><ul><li>定义子问题：一个问题可以拆成一堆子问题求解</li><li>写出子问题的递推关系：一个问题可以由其他子问题求解出来</li><li>确定 DP 数组的计算顺序：自底向上还是自顶向下</li><li>空间优化（可选）</li></ul>',17)]))}const b=a(r,[["render",i]]);export{u as __pageData,b as default};
