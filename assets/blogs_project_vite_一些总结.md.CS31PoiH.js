import{_ as t,c as o,ag as a,o as l}from"./chunks/framework.BcCMgSRd.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/project/vite/一些总结.md","filePath":"blogs/project/vite/一些总结.md","lastUpdated":1737013267000}'),i={name:"blogs/project/vite/一些总结.md"};function r(d,e,c,n,s,p){return l(),o("div",null,e[0]||(e[0]=[a('<h3 id="如何调试" tabindex="-1">如何调试 <a class="header-anchor" href="#如何调试" aria-label="Permalink to &quot;如何调试&quot;">​</a></h3><ol><li><a href="https://juejin.cn/post/7291186319355150373?searchId=20240604173952FBAB07EA047A730A6D92" target="_blank" rel="noreferrer">https://juejin.cn/post/7291186319355150373?searchId=20240604173952FBAB07EA047A730A6D92</a></li><li><a href="https://cloud.tencent.com/developer/article/2025098" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/2025098</a></li></ol><h3 id="具体步骤" tabindex="-1">具体步骤 <a class="header-anchor" href="#具体步骤" aria-label="Permalink to &quot;具体步骤&quot;">​</a></h3><ol><li>切换到<code>packages/vite/</code>下面，将vite软链到指定的项目目录。例如 <code>pnpm link ../../playground</code>添加到我们的示例项目，也可以创建一个新项目进行调试</li><li>切换到我们需要打包或者要启动的项目中，例如<code>playground/alias</code>中，然后安装依赖，可以确认下<code>vite</code>是否软链到我们的<code>vite</code>项目中。然后执行<code>npm run dev</code>(本质就是执行<code>vite dev</code>)。</li><li>启用<code>vscode</code>的<code>node</code>调试功能，在制定的位置打上断点就可以开始调试了。</li></ol><h3 id="其他办法" tabindex="-1">其他办法 <a class="header-anchor" href="#其他办法" aria-label="Permalink to &quot;其他办法&quot;">​</a></h3><ol><li>切换到<code>packages/vite/</code>下面，运行<code>pnpm run dev</code></li><li>切换到我们需要打包或者要启动的项目中，例如<code>playground/alias</code>中，然后安装依赖，然后添加命令<code>&quot;dev-debug&quot;: &quot;node ../../packages/vite/bin/vite --debug&quot;,</code>，执行就可以了。</li></ol><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><ol><li>启动服务器 <ul><li>connect实现</li><li>一堆中间件</li></ul></li><li>依赖预构建</li></ol><ul><li>为什么要预构建(两个原因)</li></ul><ol start="3"><li>请求拦截和资源编译</li><li>HMR</li></ol><h2 id="记录" tabindex="-1">记录 <a class="header-anchor" href="#记录" aria-label="Permalink to &quot;记录&quot;">​</a></h2><p>import是异步请求，所以我们。所以在vite中如果遇到了<code>import</code>语法，我们需要先等<code>import</code>文件加载好了才算成功</p><h2 id="常见插件" tabindex="-1">常见插件 <a class="header-anchor" href="#常见插件" aria-label="Permalink to &quot;常见插件&quot;">​</a></h2><ol><li>vite:css 用来执行css的转换</li></ol><h2 id="具体流程" tabindex="-1">具体流程 <a class="header-anchor" href="#具体流程" aria-label="Permalink to &quot;具体流程&quot;">​</a></h2><p>资源拦截和编译</p><ol><li>拦截html -&gt; 转换为ast -&gt; 遍历ast -&gt; 分析里面的导入 -&gt; 建立模块依赖图 -&gt; 转换文件 -&gt; 返回文件</li><li>viteTransformMiddleware -&gt; transformRequest -&gt; doTransform -&gt; loadAndTransform -&gt; 1. pluginContainer.load; 2. pluginContainer.transform -&gt; 返回结果 （注意，这里面会建立一个依赖图谱的缓存）</li></ol><h2 id="话术总结" tabindex="-1">话术总结 <a class="header-anchor" href="#话术总结" aria-label="Permalink to &quot;话术总结&quot;">​</a></h2><ol><li>vite中就是通过大量的plugin 和 server 中间件来完成 资源拦截+编译 和 HMR。由于涉及大量的异步操作，导致整个源码读起来不太友好，编辑器中经常跳来跳去。只能通过执行栈来分析。</li></ol><h2 id="为什么用import-meta-hot实现hmr" tabindex="-1">为什么用import.meta.hot实现HMR <a class="header-anchor" href="#为什么用import-meta-hot实现hmr" aria-label="Permalink to &quot;为什么用import.meta.hot实现HMR&quot;">​</a></h2><p>在 Vite 中，处理 HTML 文件和其中的 <code>&lt;script&gt;</code> 标签的方式是为了优化开发环境的加载速度和模块热更新（HMR）。这种处理方式具体体现在以下几个方面：</p><ol><li><p>利用浏览器的 ES 模块缓存 当 Vite 处理一个 HTML 文件中的 <code>&lt;script type=&quot;module&quot;&gt; </code>标签时，它会将这些脚本视为入口点。这些脚本会被请求并作为 ES 模块处理。由于浏览器原生支持 ES 模块，浏览器会自动缓存已加载的模块。这意味着在开发过程中，只有改变的模块会被重新请求和加载，未改变的模块将从缓存中快速加载，从而提高了开发环境的响应速度和效率。</p></li><li><p>热模块替换（HMR） Vite 的热模块替换（HMR）机制依赖于能够精确控制哪些模块和代码需要更新。通过将<code>&lt;script&gt;</code>标签中的内容拆分为单独的文件，Vite 可以更精确地追踪到每个模块的依赖关系和状态变化。当某个模块或其依赖发生变化时，Vite 可以仅重新加载影响到的模块，而不需要重新加载整个应用，这大大提高了开发效率。</p></li><li><p>代码转换和优化 在开发模式下，Vite 需要对 JavaScript 代码进行一些转换，例如 JSX 转换、TypeScript 编译等。将 <code>&lt;script&gt;</code> 标签内容拆分为单独的文件可以让 Vite 在处理这些转换时更加灵活和高效。此外，Vite 还可以应用其他优化，如模块解析优化、依赖预加载等。</p></li><li><p>错误和调试 将 <code>&lt;script&gt;</code> 内容拆分到单独的文件还有助于错误追踪和调试。当开发者在浏览器的开发者工具中查看源代码时，拆分后的文件结构使得代码更加清晰，错误更容易定位。</p></li></ol>',22)]))}const m=t(i,[["render",r]]);export{u as __pageData,m as default};
