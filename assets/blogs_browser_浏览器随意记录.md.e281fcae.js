import{_ as l,o as e,c as t,U as i}from"./chunks/framework.11867af4.js";const o="/front-knowledge/assets/image-20240119112843499.4a7bb8da.png",g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/browser/浏览器随意记录.md","filePath":"blogs/browser/浏览器随意记录.md","lastUpdated":1730086750000}'),r={name:"blogs/browser/浏览器随意记录.md"},a=i('<ol><li>从进程角度来看</li></ol><ul><li>用户输入<code>url</code>地址(关键字，会将关键字根据默认的引擎生成地址)。会开始导航，是在浏览器进程里面做的。</li><li>浏览器进程会准备一个渲染进程用于渲染页面</li><li>通过网络进程加载资源，最终将加载的资源交给渲染进程来处理</li><li>渲染完毕</li></ul><ol start="2"><li><p>网络七层模型</p><ul><li>物理层</li><li>数据链路层 （可以和物理层合并）</li><li>网络层 (ip)</li><li>传输层 ( tcp（安全可靠，分段传输），UDP（可能会丢包） )</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><p>一般会将后面三层合并为应用层 ( http )</p></li><li><p>从请求上来说</p></li></ol><ul><li>域名 <code>DNS</code> 解析为 ip地址 + 端口。DNS其实就是一个映射关系，是基于UDP协议的</li><li>请求时https 需要SSL协商</li><li>ip地址寻址，可能不是立马就会发送（最多发送6个http请求，有限制的）排队等待</li><li>tcp 三次握手创建链接用于传输</li><li>利用tcp传输数据（拆分成数据包进行传输，传输的包是有序的）-- 可靠，有序。服务器会按照顺序接受然后重排</li><li>http请求 (请求行 请求头 请求体) 默认不会断开 keep-alive。为了下次传输数据时可以服用上次创建的链接</li><li>服务器收到数据后 解析 (请求行 请求头 请求体)，然后响应（响应行，响应头，响应体） <ul><li>状态码 301, 302(临时)会进行重定向操作。</li><li>304状态码 回去查询浏览器缓存进行返回</li></ul></li></ul><p>可以访问jd.com在network里面看看 jd.com(302)-&gt;www.jd.com(302) -&gt;<a href="https://www.jd.com" target="_blank" rel="noreferrer">https://www.jd.com</a></p><img src="'+o+'" alt="image-20240119112843499" style="zoom:50%;"><p>stalled - 复用，代理啥的</p><p>可以<a href="https://developer.chrome.com/docs/devtools/network/reference?utm_source=devtools&amp;hl=zh-cn#timing-explanation" target="_blank" rel="noreferrer">https://developer.chrome.com/docs/devtools/network/reference?utm_source=devtools&amp;hl=zh-cn#timing-explanation</a> 查看</p><h2 id="渲染过程" tabindex="-1">渲染过程 <a class="header-anchor" href="#渲染过程" aria-label="Permalink to &quot;渲染过程&quot;">​</a></h2><p>CSS放顶端，JS放在低端，因为CSS不会阻塞，但是JS会阻塞</p><p>解析HTML -&gt; 解析CSS -&gt; 合成layers -&gt; paint -&gt; 合成</p><ul><li>页面加载的时候会先扫面link和script标签</li></ul><p>样式在顶部的时候才会渲染dom时等待css</p><p>但是样式放在底部会渲染两次。放到下面就会重绘</p><p>js会阻塞html解析和渲染，但是js要等待上面的CSS加载完毕才行，因为要保证页面的js可以操作样式。</p>',15),p=[a];function s(c,n,_,d,m,h){return e(),t("div",null,p)}const S=l(r,[["render",s]]);export{g as __pageData,S as default};
