import{_ as t,c as e,ag as r,o}from"./chunks/framework.CC6fhYpF.js";const l="/front-knowledge/assets/7f3ad40391a64a30a938baf170228a6f~tplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg___q75.Cy4Zoay9.awebp",i="/front-knowledge/assets/5381e5984bd14d789cec6c8623bff2fc~tplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg___q75.CM6JFIJC.awebp",m=JSON.parse('{"title":"浏览器其他知识杂记","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/browser/杂记.md","filePath":"blogs/browser/杂记.md","lastUpdated":1734342464000}'),p={name:"blogs/browser/杂记.md"};function n(s,a,c,d,h,u){return o(),e("div",null,a[0]||(a[0]=[r('<h1 id="浏览器其他知识杂记" tabindex="-1">浏览器其他知识杂记 <a class="header-anchor" href="#浏览器其他知识杂记" aria-label="Permalink to &quot;浏览器其他知识杂记&quot;">​</a></h1><h2 id="为什么遇到js会阻塞html的解析" tabindex="-1">为什么遇到js会阻塞html的解析 <a class="header-anchor" href="#为什么遇到js会阻塞html的解析" aria-label="Permalink to &quot;为什么遇到js会阻塞html的解析&quot;">​</a></h2><p>在浏览器中，JavaScript 的下载和执行会阻塞 HTML 文档的解析，主要是因为 JavaScript 可能会修改 DOM（文档对象模型）或影响页面的布局和样式。以下是一些具体原因：</p><ol><li><p>顺序执行：浏览器在解析 HTML 时，会逐行读取并构建 DOM 树。当遇到 <code>&lt;script&gt;</code> 标签时，浏览器会暂停 DOM 的解析，去下载和执行 JavaScript 代码。这是因为 JavaScript 可能会对 DOM 进行修改，浏览器需要确保在执行 JavaScript 之前，DOM 是最新的状态。</p></li><li><p>可能的 DOM 修改：JavaScript 可以添加、删除或修改 DOM 元素。如果在解析 HTML 的过程中，浏览器继续解析而不等待 JavaScript 执行，可能会导致 DOM 状态不一致，从而引发错误或不预期的行为。</p></li><li><p>性能考虑：如果 JavaScript 代码需要访问或操作 DOM，浏览器需要确保在执行这些代码时，DOM 是完整的。因此，阻塞解析可以避免潜在的性能问题和复杂的状态管理。</p></li></ol><p>为了避免这种阻塞，开发者可以采取以下几种方法：</p><ul><li><p>将 <code>&lt;script&gt;</code> 标签放在文档底部：将 JavaScript 文件放在 <code>&lt;body&gt;</code> 标签的末尾，这样可以确保在执行 JavaScript 之前，HTML 文档已经完全解析。</p></li><li><p>使用 async 属性：在 <code>&lt;script&gt;</code> 标签中添加 async 属性，表示该脚本可以异步下载和执行，不会阻塞 HTML 的解析。</p></li><li><p>使用 defer 属性：在 <code>&lt;script&gt;</code> 标签中添加 defer 属性，表示该脚本会在文档解析完成后执行，这样也不会阻塞 HTML 的解析。</p></li></ul><p>通过这些方法，开发者可以优化页面加载性能，减少 JavaScript 对 HTML 解析的阻塞影响。</p><blockquote><p>需要注意的是，link 元素不会阻塞 DOM 树的构建过程，但会阻塞 Render Tree 的构建过程。 这是因为 Render Tree 在构建时，需要对应的 CSSOM Tree。</p></blockquote><h2 id="字节码和机器码" tabindex="-1">字节码和机器码 <a class="header-anchor" href="#字节码和机器码" aria-label="Permalink to &quot;字节码和机器码&quot;">​</a></h2><p>字节码（Bytecode）和机器码（Machine Code）是计算机编程和执行中的两个重要概念，它们在执行环境、可移植性和执行效率等方面存在显著区别。以下是它们的主要区别：</p><h3 id="_1-定义" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to &quot;1\\. 定义&quot;">​</a></h3><ul><li><p><strong>字节码</strong>：字节码是一种中间代码，通常由高级编程语言编译器生成。它不是直接由硬件执行的，而是由虚拟机（如 Java 虚拟机 JVM 或 Python 的 CPython）解释或编译成机器码。字节码通常是平台无关的，可以在不同的操作系统和硬件上运行，只要有相应的虚拟机。</p></li><li><p><strong>机器码</strong>：机器码是计算机硬件能够直接理解和执行的二进制代码。它是特定于某种处理器架构的（如 x86、ARM 等），并且与硬件紧密相关。机器码是最终的执行代码，直接与计算机的 CPU 交互。</p></li></ul><h3 id="_2-可移植性" tabindex="-1">2. 可移植性 <a class="header-anchor" href="#_2-可移植性" aria-label="Permalink to &quot;2\\. 可移植性&quot;">​</a></h3><ul><li><p><strong>字节码</strong>：由于字节码是中间代码，它具有较好的可移植性。只要有相应的虚拟机，字节码可以在不同的平台上运行，而无需重新编译。</p></li><li><p><strong>机器码</strong>：机器码是特定于某种硬件架构的，因此它的可移植性较差。不同的处理器架构需要不同的机器码，不能直接在其他架构上运行。</p></li></ul><h3 id="_3-执行方式" tabindex="-1">3. 执行方式 <a class="header-anchor" href="#_3-执行方式" aria-label="Permalink to &quot;3\\. 执行方式&quot;">​</a></h3><ul><li><p><strong>字节码</strong>：字节码通常需要通过虚拟机进行解释或即时编译（JIT，Just-In-Time Compilation）才能转换为机器码并执行。这个过程可能会引入一些性能开销，但也提供了更好的跨平台支持。</p></li><li><p><strong>机器码</strong>：机器码可以直接由 CPU 执行，通常执行效率较高，因为它不需要额外的解释或编译步骤。</p></li></ul><h3 id="_4-生成过程" tabindex="-1">4. 生成过程 <a class="header-anchor" href="#_4-生成过程" aria-label="Permalink to &quot;4\\. 生成过程&quot;">​</a></h3><ul><li><p><strong>字节码</strong>：字节码是由高级语言编译器生成的中间代码，通常在编译时生成。它的设计目的是为了在虚拟机上运行。</p></li><li><p><strong>机器码</strong>：机器码是由编译器将源代码（通常是高级语言）直接编译生成的，针对特定的硬件架构。</p></li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>字节码</strong> 是一种中间代码，具有良好的可移植性，依赖于虚拟机执行。</li><li><strong>机器码</strong> 是特定于硬件的二进制代码，能够被 CPU 直接执行，执行效率高但可移植性差。</li></ul><p>这两者在现代编程语言和运行时环境中扮演着重要的角色，尤其是在需要跨平台支持的应用程序中。</p><h2 id="浏览器渲染合成-composite" tabindex="-1">浏览器渲染合成（<strong>composite</strong>） <a class="header-anchor" href="#浏览器渲染合成-composite" aria-label="Permalink to &quot;浏览器渲染合成（**composite**）&quot;">​</a></h2><h3 id="浏览器渲染整体过程" tabindex="-1">浏览器渲染整体过程 <a class="header-anchor" href="#浏览器渲染整体过程" aria-label="Permalink to &quot;浏览器渲染整体过程&quot;">​</a></h3><ul><li><p>但是在这个执行过程中，渲染引擎在拿到一个页面后，对HTML解析的时候遇到了JavaScript标签，应该怎么办呢？</p><ul><li>会停止解析HTML，而去加载和执行JavaScript代码</li></ul><p><img src="'+l+'" alt="渲染引擎工作流程"></p><p><strong>图2-8 渲染引擎工作流程</strong></p></li></ul><p>如图2-8所示的是渲染引擎的整个工作过程，第一次接触会觉得有点复杂，我们可以先简单了解它的过程，接下来对其进行详细的解析：</p><p>（1）解析 HTML 文件，构建 DOM（文档对象模型）树。这个树代表了页面上所有元素的节点结构</p><p>（2）解析 CSS 文件，构建 CSSOM 树。</p><p>（3）将 DOM 树和 CSSOM 树合并成渲染树。</p><p>（4）生成布局树，计算每个元素在页面上的位置和大小。</p><p>（5）根据布局绘制渲染树，将渲染树上的元素绘制成屏幕上的像素。</p><p>（6）合成层，将多个图层合并成一个图层，以便使用 GPU 进行加速。</p><p>（7）使用 GPU 加速，对图层进行合成，形成最终的图像。</p><p>（8）如果发生重绘或回流操作，重新执行步骤 4-7。</p><p>（9）有些操作会触发重绘或回流，如改变元素的位置、大小、颜色等。这些操作会影响页面的性能和渲染速度，因此需要尽可能避免。</p><h3 id="多合成层" tabindex="-1">多合成层 <a class="header-anchor" href="#多合成层" aria-label="Permalink to &quot;多合成层&quot;">​</a></h3><p>绘制的过程，可以将布局后的元素绘制到多个合成图层中。</p><ul><li>这是浏览器的一种优化手段；</li></ul><p>默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的；</p><p>而一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用GPU来加速绘制；</p><ul><li><p>因为每个合成层都是单独渲染的；</p><p><img src="'+i+'" alt="合成层效果"></p><p><strong>图2-13 合成层效果</strong></p></li></ul><p>有些属性可以触发合成层的创建，包括：</p><p>（1）3D 变换（3D Transforms）：如 rotateX、rotateY、translateZ 等属性，可以创建一个新的合成层。</p><p>（2）video、canvas、iframe 等标签：这些标签会创建一个新的合成层。</p><p>（3）opacity 动画转换时：当元素透明度发生变化时，会创建一个新的合成层。</p><p>（4）position: fixed：将元素定位为固定位置时，也会创建一个新的合成层。</p><p>（5）will-change 属性：可以通过这个实验性的属性，告诉浏览器元素可能会发生哪些变化，从而预先创建合成层。</p><p>（6）动画（Animation）或过渡（Transition）设置了 opacity、transform 属性时，也会创建一个新的合成层。</p><p>需要注意的是，过度使用合成层也会带来一些问题，如占用更多的内存、增加页面的复杂度等。</p><ul><li>因此，在使用合成层时需要谨慎，避免滥用。</li></ul><h3 id="究竟是多个图层合成一层还是分成多个图层" tabindex="-1">究竟是多个图层合成一层还是分成多个图层 <a class="header-anchor" href="#究竟是多个图层合成一层还是分成多个图层" aria-label="Permalink to &quot;究竟是多个图层合成一层还是分成多个图层&quot;">​</a></h3><p>图层的数量的多与少会直接影响浏览器的开销，看似合并起来，数量少了开销更小，统一CPU加速的负担更小，但合并后会导致改动其中一点，所有合并图层一并重绘</p><p>所以就很清晰了，像一些静态的图层就可以合起来，节约浏览器的资源。关键动态元素拆分到多个图层进行独立渲染，这样当这些高频改变的元素变化时，不需要重绘整个页面，只重绘我们特地切割出来的一小部分，开销相对于整体渲染就会小，页面响应度就更快</p><p>因此哪种方式更便于浏览器处理，在于元素是静态还是动态，浏览器会根据实际的开销进行判断选择方式</p><ul><li>参考：<a href="https://juejin.cn/post/7405413046902210612#heading-4" target="_blank" rel="noreferrer">https://juejin.cn/post/7405413046902210612#heading-4</a></li></ul>',54)]))}const b=t(p,[["render",n]]);export{m as __pageData,b as default};
